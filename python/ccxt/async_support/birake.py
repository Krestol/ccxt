# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
import math
import json
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidAddress
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import ExchangeNotAvailable
from ccxt.base.errors import InvalidNonce
from ccxt.base.decimal_to_precision import ROUND

import dateutil.parser


class birake(Exchange):

    def describe(self):
        return self.deep_extend(super(birake, self).describe(), {
            'id': 'birake',
            'name': 'Birake',
            'countries': ['NZ', 'EE'],  # Japan, Malta
            'rateLimit': 500,
            'certified': True,            
            'has': {
                'CORS': False,
                'fetchBidsAsks': True,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTime': True,
                'fetchMyTrades': False,
                'fetchOpenOrders': True,
                'fetchClosedOrders': True,
            },
            'urls': {
                'logo': 'https://trade.birake.com/logos/birake.png',
                'api': {
                    'public': 'https://api.birake.com/public',
                    'private': 'https://api.birake.com/private',
                },
                'www': 'https://birake.com/',
                'doc': 'https://api.birake.com/',
                'fees': '',
            },
            'api': {
                'public': {
                    'get': [
                        'assets',
                        'markets',
                        'depth/{symbol}',
                        'trades/{market}',
                        'ticker',
                    ],
                },
                'private': {
                    'post': [
                        'balances',
                        'history',
                        'openorders',
                        'limitOrders',
                        'addOrder',
                        'cancel'
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'taker': 0.0015,
                    'maker': 0.0015,
                },
            },
            'precision': {
                'amount': 8,
                'price': 8,
            },           
        })

    def nonce(self):
        return self.milliseconds()

    async def fetch_markets(self, params = {}):
        response = await self.publicGetTicker(params)
        result = []
        for market in response:
            symbol = self.safe_string(market, 'tradingPairs')
            api = self.safe_value (market, 'tradingUrl')
            ids = symbol.split('_', 2)
            quoteId = ids[0].upper()
            baseId = ids[1].upper()
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)

            result.append(self.extend(self.fees['trading'], {
                'info': market,
                'id': symbol,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'active': True,
                'limits': {
                    'amount': {
                        'min': None,
                        'max': None,
                    },
                },
                'precision': self.precision
            }))
        return result

    def parse_ticker(self, ticker, market = None):
        dateTime = self.safe_string(ticker, 'lastUpdateTimestamp')
        date = dateutil.parser.parse(dateTime)
        timestamp = int(date.timestamp() * 1000)
        symbol = self.safe_string(market, 'symbol')
        info = ticker
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_float(ticker, 'highestBid'),
            'low': self.safe_float(ticker, 'lowestAsk'),
            'bid': self.safe_float(ticker, 'highestBid'),
            'bidVolume': None,
            'ask': self.safe_float(ticker, 'lowestAsk'),
            'askVolume': None,
            'vwap': None,
            'open': None,
            'close': None,
            'last': self.safe_float(ticker, 'lastPrice'),
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': self.safe_float (ticker, 'baseVolume24h'),
            'quoteVolume': self.safe_float (ticker, 'quoteVolume24h'),
            'info': info,
        }

    async def fetch_ticker(self, symbol, params = {}):
        tickers = await self.fetch_tickers(symbol, params)
        if symbol in tickers:
            return tickers[symbol]
        return None

    async def fetch_tickers(self, symbol = None, params = {}):
        await self.load_markets()
        response = await self.publicGetTicker(params)
        result = {}
        for entry in response:
            marketId = self.safe_string(entry, 'tradingPairs')
            market = self.markets_by_id[marketId]
            if symbol is not None :
                if market['symbol'] == symbol:
                    result[symbol] = self.parse_ticker(entry, market)
                    break
            else:
                result[market['symbol']] = self.parse_ticker(entry, market)

        return result

    async def fetch_order_book(self, symbol, limit = None, params = {}):
        self.load_markets()
        request = {
            'symbol': symbol,
        }
        response = await self.publicGetDepthSymbol(self.extend(request, params))
        return self.parse_order_book(response, None, 'buys', 'sells', 'price', 'amount') 

    async def fetch_trades(self, symbol, since = None, limit = None, params = {}):
        await self.load_markets()
        market = self.market(symbol)
        request = {
            'market': market['id'],
        }
        response = await self.publicGetTradesMarket(self.extend(request, params))
        return self.parse_trades(response, market, since, limit)

    def parse_trade(self, trade, market=None):
        dateTime = self.safe_string(trade, 'time')
        date = dateutil.parser.parse(dateTime)
        timestamp = int(date.timestamp() * 1000)        
        price = self.safe_float(trade, 'price')
        amount = self.safe_float(trade, 'volume')
        marketId = self.safe_string(trade, 'marketPair')
        market = self.safe_value (self.markets_by_id, marketId, market)
        symbol = None if market is None else market['symbol']
        cost = self.cost_to_precision(symbol, price * amount)  
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': self.safe_string(trade, 'id'),
            'order': self.safe_string(trade, 'tradeId'),
            'type': self.safe_string(trade, 'type'),
            'side': None,
            'takerOrMaker': 'maker' if trade['isBuyerMaker'] else 'taker' ,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': None,
        }

    async def fetch_balance(self, params = {}):
        await self.load_markets()
        response = await self.privatePostBalances(params)
        result = {}
        for balance in response:
            currencyId = self.safe_string(balance, 'symbol').upper()
            currency = None
            if currencyId in self.currencies_by_id:
                currency = self.currencies_by_id[currencyId]['code']
            else:
                currency = self.common_currency_code(currencyId)
            free = self.safe_float(balance, 'amount')
            result[currency] = {
                'free': free,
                'used': None,
                'total': free,
            }

        return self.parse_balance(result)


    async def fetch_open_orders(self, symbol = None, since = None, limit = None, params = {}):
        await self.load_markets()
        response = await self.privatePostOpenorders(params)
        for order in response:
            order['status']: 'wait'
        market = None
        return self.parse_orders(response, market, since, limit)

    def parse_order(self, order, market = None):
        symbol = None
        marketId = self.safe_string(order, 'market')
        market = self.safe_value(self.markets_by_id, marketId)
        feeCurrency = None
        if market is not None:
            symbol = market['symbol']
            feeCurrency = market['quote']

        return {
            'id': self.safe_string (order, 'id'),
            'datetime': None,
            'timestamp': None,
            'lastTradeTimestamp': None,
            'status': self.safe_string(order, 'status'),
            'symbol': marketId,
            'type': 'limit',
            'side': self.safe_string(order, 'type'),
            'price': self.safe_float(order, 'price'),
            'cost': None,
            'average': None,
            'amount': self.safe_float(order, 'amount'),
            'filled': None,
            'remaining': self.safe_float(order, 'amount'),
            'trades': None,
            'fee': self.calculate_fee(marketId, 'limit', self.safe_string(order, 'type'), self.safe_float(order, 'amount'), self.safe_float(order, 'price')),
            'info': order,
        }        

    async def fetch_closed_orders(self, symbol = None, since = None, limit = None, params = {}):
        await self.load_markets()
        response = await self.privatePostHistory(params)
        for order in response:
            order['status']: 'closed'
        market = None
        
        return self.parse_orders(response, market, since, limit)

    async def create_order(self, symbol, ordType, side, amount, price = None, params = {}):
        await self.load_markets()
        market = self.market(symbol)
        params = 'market={}&amount={}&type={}&price={}'.format(
            market['id'],
            self.amount_to_precision(symbol, amount),
            side,
            price)        

        response = self.privatePostAddorder(params)
        openedOrders = self.safe_value(response, 'open')
        filledOrders = self.safe_value(response, 'filled')
        order = None
        id = None
        openAmount = 0
        totalCost = 0
        if openedOrders is not None and isinstance(openedOrders, list) and len(openedOrders) >= 1:
            order = openedOrders[0]            
            id = self.safe_string(order, 'id')
            openAmount = order['amount']
            totalCost += float(order['price']) * openAmount
        filledAmount = 0    
        if filledOrders is not None and isinstance(filledOrders, list):
            for trade in filledOrders:
                if order is None:
                    order = trade                      
                    id = self.safe_string(order, 'id')
                filledAmount += trade['amount']
                totalCost += float(trade['price']) * trade['amount']
        order = self.parse_order(order, market)
        amount = max(amount, openAmount + filledAmount)
        order['amount'] = amount
        order['remaining'] = self.amount_to_precision(market['id'], amount - filledAmount)
        order['side'] = side
        order['average'] = totalCost / amount
        order['price'] = price
        order['fee'] = self.calculate_fee(symbol, type, side, amount, order['average'])
        order['status'] = 'open'
        self.orders[id] = order
        return order

    async def cancel_order(self, id, symbol = None, params = {}):
        params = "orderId={}".format(id)
        response = await self.privatePostCancel(params)
        return response 

    async def fetch_order(self, id, symbol = None, params = {}):        
        openOrders = await self.fetch_open_orders()
        for order in openOrders:
            if order['id'] == id:
                order['status'] = 'open'
                return order       
        raise InvalidOrder('Warning: Order id ' + id + ' is not found in open orders. Maybe the order is already closed.')


    async def calculate_fee(self, symbol, type, side, amount, price, takerOrMaker='taker', params={}):
        await self.load_markets()
        market = self.markets[symbol]
        rate = market[takerOrMaker]
        return {
            'rate': rate,
            'type': takerOrMaker,
            'currency': market['quote'],
            'cost': float(self.fee_to_precision(symbol, rate * amount)),
        }

    def sign(self, path, api = 'public', method = 'GET', params = {}, headers = None, body = None):
        url = self.urls['api'][api]
        if path == 'addOrder' or path == 'cancel':
            url += '/' + 'v4'
            body = params            
        elif path != 'balances' and path != 'openorders' and path != 'history':
            url += '/' + 'v3'
        
        url += '/' +  self.implode_params(path, params)

        if api is not 'public':
            headers = {
                "birake-user": self.user,
                "birake-authorization": self.password,
                'Content-Type': "application/x-www-form-urlencoded"
            }
        return {'url': url, 'method': method, 'body': body, 'headers': headers}